/* 
 * Auto-generated TypeScript File by UiRtc
 * Version: 1.0.
 * Generated on: 2025-02-15 19:42:39 UTC 
 * Do not modify this file manually.
 */
/* eslint-disable */
/* tslint:disable */

import {
  HubConnection,
  HubConnectionBuilder,
  HubConnectionState
} from "@microsoft/signalr";

type uiRtcHubs = 'Chat';
const allHubs: uiRtcHubs[] = ['Chat'];

type hubMethods = ChatMethod;

type ChatMethod = 'Join' | 'Message' | 'RefreshHandler';

type hubSubscriptions = ChatSubscription;

type ChatSubscription = 'OnMessage' | 'UserListUpdate' | 'OnUpdate';

const connections: RConnections = {
    Chat: {},
};

export const uiRtcSubscription = {
    Chat: {
    OnMessage: (callBack: (data: MessageUiModel) => void) => subscribe("Chat", "OnMessage", callBack),
    UserListUpdate: (callBack: (data: UsersListUiModel) => void) => subscribe("Chat", "UserListUpdate", callBack),
    OnUpdate: (callBack: (data: FullUpdateUiModel) => void) => subscribe("Chat", "OnUpdate", callBack),
  },

};

export const uiRtcCommunication = {
    Chat: {
    Join: (request: NewUserRequestUiModel) => send("Chat", "Join", request),
    Message: (request: NewMessageUiModel) => send("Chat", "Message", request),
    RefreshHandler: () => send("Chat", "RefreshHandler"),
  },

};

/* THIS (.ts) FILE IS GENERATED BY Tapper */
/* eslint-disable */
/* tslint:disable */

/** Transpiled from Chat.Communicator.UiModels.FullUpdateUiModel */
export type FullUpdateUiModel = {
    /** Transpiled from System.Collections.Generic.IEnumerable<Chat.Communicator.UiModels.UserUiModel> */
    usersList: UserUiModel[];
    /** Transpiled from System.Collections.Generic.IEnumerable<Chat.Communicator.UiModels.MessageUiModel> */
    messagesList: MessageUiModel[];
    /** Transpiled from Chat.Communicator.UiModels.UserUiModel */
    currentUser: UserUiModel;
}

/** Transpiled from Chat.Communicator.UiModels.MessageUiModel */
export type MessageUiModel = {
    /** Transpiled from string */
    authorName: string;
    /** Transpiled from string */
    message: string;
    /** Transpiled from System.DateTime */
    createDate: (Date | string);
    /** Transpiled from bool */
    isPrivate: boolean;
    /** Transpiled from string? */
    recipientName?: string;
}

/** Transpiled from Chat.Communicator.UiModels.NewMessageUiModel */
export type NewMessageUiModel = {
    /** Transpiled from string */
    message: string;
    /** Transpiled from System.Guid */
    recipientId?: string;
}

/** Transpiled from Chat.Communicator.UiModels.NewUserRequestUiModel */
export type NewUserRequestUiModel = {
    /** Transpiled from string */
    name: string;
}

/** Transpiled from Chat.Communicator.UiModels.UsersListUiModel */
export type UsersListUiModel = {
    /** Transpiled from System.Collections.Generic.IEnumerable<Chat.Communicator.UiModels.UserUiModel> */
    list: UserUiModel[];
}

/** Transpiled from Chat.Communicator.UiModels.UserUiModel */
export type UserUiModel = {
    /** Transpiled from System.Guid */
    id: string;
    /** Transpiled from string */
    name: string;
}



/* Hard code */
export interface IUiRtcConfiguration {
    serverUrl: string;
    activeHubs: uiRtcHubs[] | "All";
}

interface IHub {
    connection?: HubConnection;
    config?: IUiRtcConfiguration;
}

type RConnections = Record<uiRtcHubs, IHub>;

export const uiRtc = {
    initAsync: async (config: IUiRtcConfiguration) => {
        const hubsToInitialize =
            config.activeHubs === "All" ? allHubs : config.activeHubs;
        await Promise.all(hubsToInitialize.map((hub) => initHubAsync(config, hub)));
    },
    disposeAsync: async (hubs: uiRtcHubs[] | "All" | undefined) => {
        const hubsToInitialize =
            hubs === "All" || hubs === undefined ? allHubs : hubs;
        await Promise.all(hubsToInitialize.map((hub) => disposeHubAsync(hub)));
    },
};

const initHubAsync = async (
    config: IUiRtcConfiguration,
    hubName: uiRtcHubs
) => {
    if (!!connections[hubName].connection) {
        console.warn(hubName + " hub has been initialized already");
        return;
    }

    connections[hubName].config = config;

    try {
        connections[hubName].connection = buildConnection(
            config.serverUrl + hubName
        );
        await connections[hubName].connection.start();
    } catch (err) {
        console.error(
            "Error while establishing connection '" + hubName + "': ",
            err
        );
    }
};

const buildConnection = (url: string) => {
    let builder = new HubConnectionBuilder();
    builder.withUrl(url);
    builder.withAutomaticReconnect();

    return builder.build();
};

const disposeHubAsync = async (hubName: uiRtcHubs) => {
    if (isConnected(hubName)) {
        try {
            await connections[hubName].connection!.stop();
            connections[hubName] = {};
        } catch (err) {
            console.error(
                "Error while establishing connection '" + hubName + "': ",
                err
            );
        }
    } else {
        console.warn(hubName + " hub has not been initialized");
    }
};

const isConnected = (hubName: uiRtcHubs) => {
    if (
        !!connections &&
        !!connections[hubName] &&
        !!connections[hubName].connection &&
        (connections[hubName].connection.state === HubConnectionState.Connected ||
            connections[hubName].connection.state === HubConnectionState.Connecting ||
            connections[hubName].connection.state === HubConnectionState.Reconnecting)
    )
        return true;
    return false;
};

const subscribe = (
    hub: uiRtcHubs,
    sub: hubSubscriptions,
    callBack: (data: any) => void
) => {
    connections[hub].connection?.on(sub, callBack);
};

const send = async (hub: uiRtcHubs, method: hubMethods, request?: any) => {
    if (!!request) {
        await connections[hub].connection?.send(method, request);
    } else {
        await connections[hub].connection?.send(method);
    }
};